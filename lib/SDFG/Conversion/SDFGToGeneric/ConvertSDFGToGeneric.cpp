// Copyright (c) 2021-2023, Scalable Parallel Computing Lab, ETH Zurich

/// This file defines a converter from the SDFG dialect to the builtin dialects.

//
// SDFG -> func.func
// States -> block
// Edges ->
//       Default: cf.br
//       Assignment: Insert block, add assignments at the end, cf.br
//       Condition: Insert blocks (true/false), compute condition, cf.cond_br
//
// Alloc -> memref.alloc
// Load -> memref.load
// Store -> memref.store
// Copy -> memref.copy
//
// Alloc Symbol -> memref.alloc (int64)
// Sym ->
//      If single symbol: memref.load
//      If expression: parse, build AST, create ops
//
// Return -> func.return
// Tasklet -> func.func + func.call
//
// Map -> scf.parallel (or: affine.parallel, affine.for, scf.forall, scf.for)
//
// Consume -> TBD
//

#include "SDFG/Conversion/SDFGToGeneric/OpCreators.h"
#include "SDFG/Conversion/SDFGToGeneric/PassDetail.h"
#include "SDFG/Conversion/SDFGToGeneric/Passes.h"
#include "SDFG/Conversion/SDFGToGeneric/SymbolicParser.h"
#include "SDFG/Dialect/Dialect.h"
#include "SDFG/Utils/Utils.h"
#include "mlir/Dialect/ControlFlow/IR/ControlFlowOps.h"
#include "mlir/Dialect/Func/IR/FuncOps.h"
#include "mlir/Dialect/MemRef/IR/MemRef.h"
#include "mlir/IR/AsmState.h"
#include "mlir/IR/IRMapping.h"
#include "mlir/Transforms/DialectConversion.h"

using namespace mlir;
using namespace sdfg;
using namespace conversion;

/// Maps state name to their generated block
llvm::StringMap<Block *> blockMap;

/// For each function scope, map symbols to values
/// Function scope is determined by the function name
llvm::StringMap<llvm::StringMap<Value>> symbolMap;

// HACK: Keeps track of processed EdgeOps
llvm::DenseSet<EdgeOp> processedEdges;

//===----------------------------------------------------------------------===//
// Target & Type Converter
//===----------------------------------------------------------------------===//

/// Defines the target to convert to.
struct GenericTarget : public ConversionTarget {
  GenericTarget(MLIRContext &ctx) : ConversionTarget(ctx) {
    // Every Op in the SDFG Dialect is illegal
    addIllegalDialect<SDFGDialect>();
    // Implicit top level module operation is legal
    addLegalOp<ModuleOp>();
    // Dialects generated by this pass are legal
    addLegalDialect<func::FuncDialect>();
    addLegalDialect<cf::ControlFlowDialect>();
    addLegalDialect<memref::MemRefDialect>();
    addLegalDialect<arith::ArithDialect>();
    addLegalDialect<scf::SCFDialect>();
    // All other operations are illegal
    markUnknownOpDynamicallyLegal([](Operation *op) { return false; });
  }
};

/// Defines a type converter, converting input types to MemRef types.
class ToMemrefConverter : public TypeConverter {
public:
  ToMemrefConverter() {
    addConversion([](Type type) { return type; });
    addConversion(convertArrayTypes);
  }

  /// Attempts to convert array types to MemRef types.
  static Optional<Type> convertArrayTypes(Type type) {
    if (ArrayType array = type.dyn_cast<ArrayType>()) {
      SmallVector<int64_t> shape;
      unsigned intIdx = 0;

      for (unsigned i = 0; i < array.getShape().size(); ++i) {
        int64_t val = array.getShape()[i] ? array.getIntegers()[intIdx++]
                                          : ShapedType::kDynamic;

        if (val < 0)
          val = ShapedType::kDynamic;
        shape.push_back(val);
      }

      return MemRefType::get(shape, array.getElementType());
    }

    return std::nullopt;
  }
};

//===----------------------------------------------------------------------===//
// Helpers
//===----------------------------------------------------------------------===//

/// Gets the current function scope.
llvm::StringRef getFunctionScope(Operation *op) {
  Operation *parent = op->getParentOfType<func::FuncOp>();
  if (parent == nullptr)
    return "";

  return cast<func::FuncOp>(parent).getName();
}

/// Creates operations that perform the symbolic expression.
static Value symbolicExpressionToMLIR(PatternRewriter &rewriter, Operation *op,
                                      StringRef symExpr,
                                      llvm::StringMap<Value> refMap = {}) {
  std::unique_ptr<ASTNode> ast = SymbolicParser().parse(symExpr);
  if (!ast)
    emitError(op->getLoc(), "failed to parse symbolic expression");

  return ast->codegen(rewriter, op->getLoc(), symbolMap[getFunctionScope(op)],
                      refMap);
}

/// Converts a numberlist (symbol, integer, operand) to Values.
static SmallVector<Value> numberListToMLIR(PatternRewriter &rewriter,
                                           Operation *op, StringRef attrName) {
  ArrayAttr attrList = op->getAttr(attrName).cast<ArrayAttr>();
  ArrayAttr numList =
      op->getAttr(attrName.str() + "_numList").cast<ArrayAttr>();
  SmallVector<Value> values;

  for (unsigned i = 0; i < numList.size(); ++i) {
    IntegerAttr num = numList[i].cast<IntegerAttr>();

    if (num.getValue().isNegative()) {
      // Number is a symbol or integer
      Attribute attr = attrList[-num.getInt() - 1];
      std::string expression;

      if (attr.isa<StringAttr>())
        expression = attr.cast<StringAttr>().str();
      else
        expression = std::to_string(attr.cast<IntegerAttr>().getInt());

      Value val = symbolicExpressionToMLIR(rewriter, op, expression);
      val =
          createIndexCast(rewriter, op->getLoc(), rewriter.getIndexType(), val);
      values.push_back(val);
    } else {
      // Number is a operand
      values.push_back(op->getOperand(num.getInt()));
    }
  }

  return values;
}

//===----------------------------------------------------------------------===//
// SDFG, State & Edge Patterns
//===----------------------------------------------------------------------===//

/// Converts a SDFG node to func::FuncOp.
class SDFGToFunc : public OpConversionPattern<SDFGNode> {
public:
  using OpConversionPattern<SDFGNode>::OpConversionPattern;

  LogicalResult
  matchAndRewrite(SDFGNode op, OpAdaptor adaptor,
                  ConversionPatternRewriter &rewriter) const override {
    // Mark the entry state
    op.getEntryState()->setAttr("entry", rewriter.getBoolAttr(true));

    // Create a function and clone the sdfg body
    SmallVector<Type> convertedTypes;
    if (getTypeConverter()
            ->convertTypes(op.getBody().getArgumentTypes(), convertedTypes)
            .failed())
      return failure();

    // Add symbols to signature
    SmallVector<StringAttr> symbols;

    for (Type t : op.getBody().getArgumentTypes())
      if (ArrayType arrayT = t.dyn_cast<ArrayType>())
        for (StringAttr sym : arrayT.getSymbols())
          if (find(symbols, sym) == symbols.end()) {
            convertedTypes.push_back(rewriter.getIndexType());
            symbols.push_back(sym);
          }

    func::FuncOp funcOp =
        createFunc(rewriter, op.getLoc(), "sdfg", convertedTypes, {}, "public");
    funcOp.getBody().takeBody(op.getBody());

    // Add symbols to scope
    for (StringAttr sym : symbols)
      symbolMap[getFunctionScope(op)][sym] =
          funcOp.getBody().addArgument(rewriter.getIndexType(), op.getLoc());

    if (failed(rewriter.convertRegionTypes(&funcOp.getBody(),
                                           *getTypeConverter())))
      return failure();

    rewriter.eraseOp(op);
    return success();
  }
};

/// Converts a nested SDFG node to func::FuncOp and func::CallOp.
class NestedSDFGToFunc : public OpConversionPattern<NestedSDFGNode> {
public:
  using OpConversionPattern<NestedSDFGNode>::OpConversionPattern;

  LogicalResult
  matchAndRewrite(NestedSDFGNode op, OpAdaptor adaptor,
                  ConversionPatternRewriter &rewriter) const override {
    // Create call
    std::string name = sdfg::utils::generateName("nested_sdfg");

    // Propagate symbols
    SmallVector<Value> operands = adaptor.getOperands();
    for (llvm::StringMapEntry<Value> &v : symbolMap[getFunctionScope(op)])
      operands.push_back(v.getValue());

    createCall(rewriter, op.getLoc(), {}, name, operands);

    // Set insertion point before the current func
    Operation *parent = op->getParentOfType<func::FuncOp>();
    if (parent == nullptr)
      return failure();

    rewriter.setInsertionPoint(parent);

    // Mark the entry state
    op.getEntryState()->setAttr("entry", rewriter.getBoolAttr(true));

    // Create a function and clone the sdfg body
    SmallVector<Type> operandTypes;
    if (getTypeConverter()
            ->convertTypes(op.getOperandTypes(), operandTypes)
            .failed())
      return failure();

    // Add symbols to signature
    for (llvm::StringMapEntry<Value> &v : symbolMap[getFunctionScope(op)])
      operandTypes.push_back(v.getValue().getType());

    func::FuncOp funcOp =
        createFunc(rewriter, op.getLoc(), name, operandTypes, {}, "private");
    funcOp.getBody().takeBody(op.getBody());

    // Add symbols to scope
    for (llvm::StringMapEntry<Value> &v : symbolMap[getFunctionScope(op)])
      symbolMap[name][v.getKey()] =
          funcOp.getBody().addArgument(v.getValue().getType(), op.getLoc());

    if (failed(rewriter.convertRegionTypes(&funcOp.getBody(),
                                           *getTypeConverter())))
      return failure();

    rewriter.eraseOp(op);
    return success();
  }
};

/// Converts a state to a basic block.
class StateToBlock : public OpConversionPattern<StateNode> {
public:
  using OpConversionPattern<StateNode>::OpConversionPattern;

  LogicalResult
  matchAndRewrite(StateNode op, OpAdaptor adaptor,
                  ConversionPatternRewriter &rewriter) const override {
    // Split the current basic block at the current position
    Block *newBlock = rewriter.createBlock(rewriter.getBlock()->getParent());

    // Add the mapping from the sdfg.state's name to the new basic block
    blockMap[op.getName()] = newBlock;

    // Connect to init block if it's an entry state
    if (op->hasAttrOfType<BoolAttr>("entry") &&
        op->getAttrOfType<BoolAttr>("entry").getValue()) {
      rewriter.setInsertionPointToEnd(&newBlock->getParent()->front());
      createBranch(rewriter, op.getLoc(), {}, newBlock);
    }

    // Move the operations from the sdfg.state's body into the new basic block
    rewriter.setInsertionPointToStart(newBlock);

    // Collect all operations
    SmallVector<Operation *> ops;
    for (Operation &operation : op.getBody().getOps()) {
      ops.push_back(&operation);
    }

    // Move them
    for (Operation *operation : ops) {
      operation->moveBefore(newBlock, newBlock->end());
    }

    // If there is an outward edge, do not add a return op
    for (EdgeOp edge : op->getParentRegion()->getOps<EdgeOp>()) {
      if (edge.getSrc().equals(op.getSymName())) {
        rewriter.eraseOp(op);
        return success();
      }
    }

    createReturn(rewriter, op.getLoc(), {});
    rewriter.eraseOp(op);
    return success();
  }
};

/// Converts an edge to basic blocks (for assignments and conditions) and
/// (conditional) branches.
class EdgeToBranch : public OpConversionPattern<EdgeOp> {
public:
  using OpConversionPattern<EdgeOp>::OpConversionPattern;

  LogicalResult
  matchAndRewrite(EdgeOp op, OpAdaptor adaptor,
                  ConversionPatternRewriter &rewriter) const override {
    // If we don't have a condition or assignments, add a simple branch
    if (adaptor.getCondition().equals("1") && adaptor.getAssign().empty()) {
      rewriter.setInsertionPointToEnd(blockMap[adaptor.getSrc()]);
      createBranch(rewriter, op.getLoc(), {}, blockMap[adaptor.getDest()]);
      rewriter.eraseOp(op);
      return success();
    }

    Block *takenBlock = rewriter.createBlock(rewriter.getBlock()->getParent());
    llvm::StringMap<Value> refMap;
    // FIXME: Extend to variable amount of references
    refMap["ref"] = adaptor.getRef();

    if (!adaptor.getCondition().equals("1")) {
      // If we have a condition, create a second block (not taken path)
      Block *notTakenBlock =
          rewriter.createBlock(rewriter.getBlock()->getParent());
      rewriter.setInsertionPointToEnd(blockMap[adaptor.getSrc()]);
      // Compute condition
      Value condition = symbolicExpressionToMLIR(
          rewriter, op, adaptor.getCondition(), refMap);
      // Add conditional branch
      createCondBranch(rewriter, op.getLoc(), condition, takenBlock,
                       notTakenBlock);

      // Update blockMap
      blockMap[adaptor.getSrc()] = notTakenBlock;

      // If there is no other edge op for the source state, add return statement
      // to the new block
      bool hasEdge = false;

      for (EdgeOp edge : rewriter.getBlock()->getParent()->getOps<EdgeOp>()) {
        if (edge.getSrc().equals(adaptor.getSrc()) && edge != op &&
            !processedEdges.contains(edge)) {
          hasEdge = true;
          break;
        }
      }

      if (!hasEdge) {
        rewriter.setInsertionPointToEnd(notTakenBlock);
        createReturn(rewriter, op.getLoc(), {});
      }
    } else {
      rewriter.setInsertionPointToEnd(blockMap[adaptor.getSrc()]);
      createBranch(rewriter, op.getLoc(), {}, takenBlock);
      // No blockMap update because only one unconditial edge allowed per state
    }

    // Add assignments
    rewriter.setInsertionPointToStart(takenBlock);

    for (Attribute assignment : adaptor.getAssign())
      symbolicExpressionToMLIR(rewriter, op, cast<StringAttr>(assignment),
                               refMap);

    // Create simple branch to destination
    createBranch(rewriter, op.getLoc(), {}, blockMap[adaptor.getDest()]);

    rewriter.eraseOp(op);
    processedEdges.insert(op);
    return success();
  }
};

//===----------------------------------------------------------------------===//
// Access Node Patterns
//===----------------------------------------------------------------------===//

/// Converts an allocation operation to memref::AllocOp.
class AllocToAlloc : public OpConversionPattern<AllocOp> {
public:
  using OpConversionPattern<AllocOp>::OpConversionPattern;

  LogicalResult
  matchAndRewrite(AllocOp op, OpAdaptor adaptor,
                  ConversionPatternRewriter &rewriter) const override {
    Type memrefType = getTypeConverter()->convertType(op.getType());
    if (!memrefType || !memrefType.isa<MemRefType>())
      return failure();

    SmallVector<Value> operands;

    if (ArrayType array = op.getType().dyn_cast<ArrayType>()) {
      unsigned intIdx = 0;
      unsigned symIdx = 0;
      unsigned opIdx = 0;

      for (unsigned i = 0; i < array.getShape().size(); ++i) {
        Value val;
        if (array.getShape()[i] && array.getIntegers()[intIdx] < 0) {
          intIdx++;
          val = op.getOperand(opIdx++);
        } else if (array.getShape()[i]) {
          intIdx++;
          continue;
        } else {
          val = symbolicExpressionToMLIR(rewriter, op,
                                         array.getSymbols()[symIdx++]);
          val = createIndexCast(rewriter, op.getLoc(), rewriter.getIndexType(),
                                val);
        }
        operands.push_back(val);
      }

    } else {
      operands = adaptor.getOperands();
    }

    memref::AllocOp allocOp = createAlloc(
        rewriter, op.getLoc(), memrefType.cast<MemRefType>(), operands);
    rewriter.replaceOp(op, {allocOp});
    return success();
  }
};

/// Converts a load operation to memref::LoadOp.
class LoadToLoad : public OpConversionPattern<LoadOp> {
public:
  using OpConversionPattern<LoadOp>::OpConversionPattern;

  LogicalResult
  matchAndRewrite(LoadOp op, OpAdaptor adaptor,
                  ConversionPatternRewriter &rewriter) const override {
    SmallVector<Value> indices = numberListToMLIR(rewriter, op, "indices");

    memref::LoadOp loadOp =
        createLoad(rewriter, op.getLoc(), adaptor.getArr(), indices);
    rewriter.replaceOp(op, {loadOp});
    return success();
  }
};

/// Converts a store operation to memref::StoreOp.
class StoreToStore : public OpConversionPattern<StoreOp> {
public:
  using OpConversionPattern<StoreOp>::OpConversionPattern;

  LogicalResult
  matchAndRewrite(StoreOp op, OpAdaptor adaptor,
                  ConversionPatternRewriter &rewriter) const override {
    SmallVector<Value> indices = numberListToMLIR(rewriter, op, "indices");
    createStore(rewriter, op.getLoc(), adaptor.getVal(), adaptor.getArr(),
                indices);
    rewriter.eraseOp(op);
    return success();
  }
};

/// Converts a copy operation to memref::CopyOp.
class CopyToCopy : public OpConversionPattern<CopyOp> {
public:
  using OpConversionPattern<CopyOp>::OpConversionPattern;

  LogicalResult
  matchAndRewrite(CopyOp op, OpAdaptor adaptor,
                  ConversionPatternRewriter &rewriter) const override {
    createCopy(rewriter, op.getLoc(), adaptor.getSrc(), adaptor.getDest());
    rewriter.eraseOp(op);
    return success();
  }
};

//===----------------------------------------------------------------------===//
// Symbol Patterns
//===----------------------------------------------------------------------===//

/// Converts a symbol allocation operation to memref::AllocOp.
class AllocSymbolToAlloc : public OpConversionPattern<AllocSymbolOp> {
public:
  using OpConversionPattern<AllocSymbolOp>::OpConversionPattern;

  LogicalResult
  matchAndRewrite(AllocSymbolOp op, OpAdaptor adaptor,
                  ConversionPatternRewriter &rewriter) const override {
    allocSymbol(rewriter, op.getLoc(), op.getSym(),
                symbolMap[getFunctionScope(op)]);
    rewriter.eraseOp(op);
    return success();
  }
};

/// Converts a symbolic expression to multiple builtin operations.
class SymToOps : public OpConversionPattern<SymOp> {
public:
  using OpConversionPattern<SymOp>::OpConversionPattern;

  LogicalResult
  matchAndRewrite(SymOp op, OpAdaptor adaptor,
                  ConversionPatternRewriter &rewriter) const override {
    Value val = symbolicExpressionToMLIR(rewriter, op, op.getExpr());

    if (op.getType().isIndex())
      val = createIndexCast(rewriter, op.getLoc(), op.getType(), val);

    if (op.getType().isIntOrIndex() && !op.getType().isIndex() &&
        !op.getType().isInteger(64))
      val = createTruncI(rewriter, op.getLoc(), op.getType(), val);

    rewriter.replaceOp(op, {val});
    return success();
  }
};

//===----------------------------------------------------------------------===//
// Tasklet Patterns
//===----------------------------------------------------------------------===//

/// Converts a tasklet to func::FuncOp and func::CallOp.
class TaskletToFunc : public OpConversionPattern<TaskletNode> {
public:
  using OpConversionPattern<TaskletNode>::OpConversionPattern;

  LogicalResult
  matchAndRewrite(TaskletNode op, OpAdaptor adaptor,
                  ConversionPatternRewriter &rewriter) const override {
    // Create call
    std::string name = sdfg::utils::generateName("tasklet");

    SmallVector<Type> resultTypes;
    if (getTypeConverter()
            ->convertTypes(op.getResultTypes(), resultTypes)
            .failed())
      return failure();

    // Propagate symbols
    SmallVector<Value> operands = adaptor.getOperands();
    for (llvm::StringMapEntry<Value> &v : symbolMap[getFunctionScope(op)])
      operands.push_back(v.getValue());

    func::CallOp callOp =
        createCall(rewriter, op.getLoc(), resultTypes, name, operands);
    rewriter.replaceOp(op, callOp.getResults());

    // Set insertion point before the current func
    Operation *parent = op->getParentOfType<func::FuncOp>();
    if (parent == nullptr)
      return failure();

    rewriter.setInsertionPoint(parent);

    // Create function
    SmallVector<Type> operandTypes;
    if (getTypeConverter()
            ->convertTypes(op.getOperandTypes(), operandTypes)
            .failed())
      return failure();

    // Add symbols to signature
    for (llvm::StringMapEntry<Value> &v : symbolMap[getFunctionScope(op)])
      operandTypes.push_back(v.getValue().getType());

    func::FuncOp funcOp = createFunc(rewriter, op.getLoc(), name, operandTypes,
                                     resultTypes, "private");
    funcOp.getBody().takeBody(op.getBody());

    // Add symbols to scope
    for (llvm::StringMapEntry<Value> &v : symbolMap[getFunctionScope(op)])
      symbolMap[name][v.getKey()] =
          funcOp.getBody().addArgument(v.getValue().getType(), op.getLoc());

    if (failed(rewriter.convertRegionTypes(&funcOp.getBody(),
                                           *getTypeConverter())))
      return failure();

    return success();
  }
};

/// Converts a return operation to func::ReturnOp.
class ReturnToReturn : public OpConversionPattern<ReturnOp> {
public:
  using OpConversionPattern<ReturnOp>::OpConversionPattern;

  LogicalResult
  matchAndRewrite(ReturnOp op, OpAdaptor adaptor,
                  ConversionPatternRewriter &rewriter) const override {
    createReturn(rewriter, op.getLoc(), op.getOperands());
    rewriter.eraseOp(op);
    return success();
  }
};

//===----------------------------------------------------------------------===//
// Map & Consume Patterns
//===----------------------------------------------------------------------===//

/// Converts a map scope to scf::ParallelOp.
class MapToParallel : public OpConversionPattern<MapNode> {
public:
  using OpConversionPattern<MapNode>::OpConversionPattern;

  LogicalResult
  matchAndRewrite(MapNode op, OpAdaptor adaptor,
                  ConversionPatternRewriter &rewriter) const override {
    SmallVector<Value> lowerBounds =
        numberListToMLIR(rewriter, op, "lowerBounds");
    SmallVector<Value> upperBounds =
        numberListToMLIR(rewriter, op, "upperBounds");
    SmallVector<Value> steps = numberListToMLIR(rewriter, op, "steps");

    scf::ParallelOp parallelOp =
        createParallel(rewriter, op.getLoc(), lowerBounds, upperBounds, steps);

    if (!op.getBodyRegion().empty() && !op.getBodyRegion().front().empty()) {
      parallelOp.getBodyRegion().takeBody(op.getBodyRegion());
      rewriter.setInsertionPointToEnd(parallelOp.getBody());
      createYield(rewriter, op.getLoc());
    }

    rewriter.eraseOp(op);
    return success();
  }
};

/// Converts a consume scope to TBD.
class ConsumeToTODO : public OpConversionPattern<ConsumeNode> {
public:
  using OpConversionPattern<ConsumeNode>::OpConversionPattern;

  LogicalResult
  matchAndRewrite(ConsumeNode op, OpAdaptor adaptor,
                  ConversionPatternRewriter &rewriter) const override {
    // TODO: Write lowering for consume nodes
    return failure();
  }
};

//===----------------------------------------------------------------------===//
// Pass
//===----------------------------------------------------------------------===//

/// Registers all the patterns above in a RewritePatternSet.
void populateSDFGToGenericConversionPatterns(RewritePatternSet &patterns,
                                             TypeConverter &converter) {
  MLIRContext *ctxt = patterns.getContext();

  patterns.add<SDFGToFunc>(converter, ctxt);
  patterns.add<NestedSDFGToFunc>(converter, ctxt);
  patterns.add<StateToBlock>(converter, ctxt);
  patterns.add<EdgeToBranch>(converter, ctxt);
  patterns.add<AllocToAlloc>(converter, ctxt);
  patterns.add<LoadToLoad>(converter, ctxt);
  patterns.add<StoreToStore>(converter, ctxt);
  patterns.add<CopyToCopy>(converter, ctxt);
  patterns.add<AllocSymbolToAlloc>(converter, ctxt);
  patterns.add<SymToOps>(converter, ctxt);
  patterns.add<TaskletToFunc>(converter, ctxt);
  patterns.add<ReturnToReturn>(converter, ctxt);
  patterns.add<MapToParallel>(converter, ctxt);
  patterns.add<ConsumeToTODO>(converter, ctxt);
}

namespace {
struct SDFGToGenericPass
    : public sdfg::conversion::SDFGToGenericPassBase<SDFGToGenericPass> {
  void runOnOperation() override;
};
} // namespace

/// Runs the pass on the top-level module operation.
void SDFGToGenericPass::runOnOperation() {
  ModuleOp module = getOperation();

  GenericTarget target(getContext());
  ToMemrefConverter converter;

  RewritePatternSet patterns(&getContext());
  populateSDFGToGenericConversionPatterns(patterns, converter);

  if (applyFullConversion(module, target, std::move(patterns)).failed())
    signalPassFailure();
}

/// Returns a unique pointer to this pass.
std::unique_ptr<Pass> conversion::createSDFGToGenericPass() {
  return std::make_unique<SDFGToGenericPass>();
}
